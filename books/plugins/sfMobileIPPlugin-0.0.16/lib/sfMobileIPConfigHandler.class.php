<?php
/* vim: set expandtab tabstop=2 shiftwidth=2 softtabstop=2: */

class sfMobileIPConfigHandler extends sfYamlConfigHandler
{
  public function execute($configFiles)
  {
    $config = $this->parseYamls($configFiles);

    // get all ip ranges
    $ranges = array();
    foreach ($config as $carrier => $carrier_ips) {
      foreach ($carrier_ips as $cidr) {
        $cidr = @Net_IPv4::parseAddress($cidr);
        $ranges[] = array(
          'broadcast' => $this->ip2double($cidr->broadcast),
          'carrier'   => $carrier,
          'network'   => $this->ip2double($cidr->network));
      }
    }

    // sort
    usort($ranges, array($this, 'compareByNetwork'));

    // unite sequent ip range
    $l = count($ranges);
    $cur =& $ranges[0];
    for ($i = 1; $i < $l; $i++) {
      $next =& $ranges[$i];
      $condition = ($cur['broadcast']+1) === $next['network'] &&
        $cur['carrier'] === $next['carrier'];
      if ($condition) {
        $cur['broadcast'] = $next['broadcast'];
        unset($ranges[$i]);
      } else {
        $cur =& $ranges[$i];
      }
    }
    $ranges = array_values($ranges);

    // compile data
    $retval = "<?php\n".
              "// auto-generated by %s\n".
              "// date: %s\n".
              "return %s;\n";
    $retval = sprintf($retval,
      __CLASS__, date('Y/m/d H:i:s'), var_export($ranges, true));

    return $retval;
  }

  protected function compareByNetwork($a, $b)
  {
    if ($a['network'] === $b['network']) {
      return 0;
    } else if ($a['network'] < $b['network']) {
      return -1;
    } else {
      return 1;
    }
  }

  protected function ip2double($addr)
  {
    return (double)(sprintf('%u', ip2long($addr)));
  }
}
